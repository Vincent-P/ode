; store-local <var_ident> <value>                    trivial
; bool / true / false                                trivial
; u8 / u32                                           kinda hard
; u32 =                                              trivial
; pointer_offset                                     done

(define (is_digit bool) (c u8)
	(and (<= '0' c) ( <= c '9')))

(define (day1 ()) (input (* u8) input-length u32)
	(let i-line 0)
	(let i-first 0)
	(let has-first false)
	(let i-last 0)
	(let i 0)
	(loop
		(if (>= i input_end) (break) ())
		(let c (load (_ptr_offset (* u8) input i)))
		(if (is_digit c)
			(if has-first
				(set i-last i)
				(seq
					(set i-first i)
					(set has-first true)))
			(if (= c '\n')
				(set i-line (+ i-line 1))
				(set has-first false)
				()))
		(set i (+ i 1))))


== Current progress:
- Implementing slices as two-elements (ptr, u32), could be implemented as a single stack element when u64 get implemented
- Builtins? or Opcodes for everything?


== Pointers
After implementing pointers, I think that strings (or pointers in general?) should embed length.
- So either all pointers have an associated length (in elements or bytes)
- Or there is a separate slice type

== Structs
How to implement structs?
The current idea is to remove "value" structs. No passing by value anywhere. No structs in local variables, no structs in function arguments.
This makes it easy to implement local variables and function arguments, as they are guaranteed to be "primitive" types.
It also mimics how assembly works.
No passing by value vs passing by reference problem.

But:
It doesn't align with what I have in mind for ode. I would like to have modules that only export table of data (struct type + array of objects).
How to implement that? Local module memory? In a sense it should work the same way as "constants" memory... So should it be possible to include constants?
"Global" variables where struct are allowed by value?

