* Questions
- Typed or untyped?
- Separate LISP language and typed bytecode? This way we can implement any language / syntax.
- Reflection not mandatory (but still wanted as a long term goal to be better than C++)
- Manual Memory management (mandatory):
  - stack = implicit?
  - heap = explicit
  - Does it make sense to stick to a C like memory model?
  - Builtin allocators that make sense (linear, arena, fixed sized, tlsf)
#+begin_src
let machin = 3                       -- (stack allocator)
let machdeux = 2
arena
#+end_src

* V0 features
** Structs
- Right now structs only define types. They do not have ctors and cannot be passed by value. Only primitives are supported. ("Structs" can still be used with pointer arithmetic)
#+begin_src ode
(struct Point
	(x i32)
	(y i32))
(let p1 (Point 1 2))
(let x1 (field p1 x))
#+end_src

** Host functions
- Necessary to implement a portable VM.
#+begin_src ode
(define-foreign (log ()) (n i32))
(log 1)
#+end_src

** Functions
- Example is invalid, we do not have structs passing and "field". Functions are still here and working...
#+begin_src ode
(define (addonetopoint i32) (p Point)
    (+ (field p x) 1))
#+end_src

** Pointers
- The goal is to have a C-like language so pointers is a must. Ideally we want pointers to be trivially convertible to C for the host and access values like regular C pointers.

* VM
The simplest VM possible only contains an operand stack, call frame stack, and bytecode. Only supports arithmetic, load/store from pointer (as uint), branching, and call frame management (call, ret, args, locals?).
If all the code is contained in one module:
  - Call <offset> can just be an offset from current IP instead of <i function>
  - Local #i can just be at base stack pointer + i
Simplest executor possible. But how to handle modules? Call a function from another module. We have to keep the current execution context (stack), but switch bytecode. So a VM with modules support would be N bytecode + 1 (operand stack/callframe stack)?
With a model like this, there is nothing to "instantiate". Bytecode is trivially loaded from a "compiled" module. But how to reference other modules?

What is the smallest and simplest VM with modules support?

Modules makes hot reload/incremental compilation easier. Just re-compile and re-link the modules with the existing runtime.
A "module" also implies something containing more data than just bytecode. It can contain types, globals, and similar higher level constructs.

Linking modules:
Each module is bytecode + a table of "imports". "imports" are external functions, from the host VM or other modules.
Each import is:
  - a module name + function name for functions imported from another module
  - function name for VM host functions (module name = "host" ?)
Now we need to "load" modules: link with other modules, or link to host functions.
Every import has to map to a module + instruction address OR a VM host index. The loading stage fills these values at load time.
When we hot-reload a module, we need to check every other module to see if it imports functions, and patch addresses.
We don't really need to have a concept of "functions", it is more like a jump table to other modules.

** Foreign functions
There are 2 main ways to communicate with the host program: foreign functions (ffi, or bindings) or syscalls.
Syscalls are inherently more hard-coded than foreign functions, but it makes the VM so much simpler. Most VM use foreign functions and we could too, but it would add a lot of complexity to the runtime.
UVM, in its quest to minimalism, does not provide foreign functions and the syscalls are kept to a minimum.
